@precedence {
  if @right,
  else @right,
  elif @right,
  member @left,
  comma @left,
  statement @cut,
  decl @cut,
  predicate
}

@top Jinja2Template { statement+ }

statement[@isGroup=Statement] {
  ContentElement |
  Block
}

ContentElement {
  ExtendsStatement |
  ImportStatement
}

Block {
  StartBlock { StartTag kw<"block"> BlockName EndTag }
  (statement | If | For | VariableStatement )+
  EndBlock { StartTag kw<"endblock"> EndTag }
}


ExtendsStatement { StartTag kw<"extends"> FileName EndTag }
ImportStatement { StartTag kw<"from"> FileName kw<"import"> ImportName WithContext? EndTag }

If { IfStatement ElifStatement* ElseStatement? EndIfStatement }
IfStatement { StartTag kw<"if"> ifExpression EndTag }
ElifStatement { StartTag kw<"elif"> ifExpression EndTag }
ElseStatement { StartTag kw<"else"> EndTag }
EndIfStatement { StartTag kw<"enif"> EndTag }

For { ForStatement VariableStatement+ EndForStatement }
ForStatement { StartTag kw<"for"> commaSep<PropertyName> kw<"in"> forExpression+ EndTag }
EndForStatement { StartTag kw<"endfor"> EndTag }
VariableStatement { StartVariable varExpression EndVariable }

// ===============================================================

ifExpression[@isGroup=IfExpressions] {
  Number |
  VariableName |
  boolean
}

forExpression[@isGroup=ForExpressions] {
  Number |
  boolean |
  VariableName |
  Range |
  ObjectArgument |
  Function
}


varExpression[@isGroup=VarExpression] {
  Number |
  boolean |
  Range |
  ObjectArgument |
  Function |
  VariableName |
  EscapedVariableName
}

Function { FunctionName "(" (PropertyName | "") ~destructure ")" }

// ======================== END =======================================
ImportName { word }
FileName { string }
BlockName { word }
FunctionName { identifier !member ("." identifier)* }
VariableName { identifier !member ("." identifier)* }
PropertyName { identifier !member ("." identifier)* }

EscapedVariableName { VariableName "|e" }

WithContext { ckw<"with"> ckw<"context"> }
kw<term> { @specialize[@name={term}]<identifier, term> }
ckw<term> { @extend[@name={term}]<identifier, term> }

boolean { @specialize[@name=BooleanLiteral]<identifier, "true" | "false"> }
commaSep<content> {
  "" | content ("," content?)*
}
// commaSep1<content> {
//   content ("," content)*
// }

@skip { spaces | newline | сomment }

@skip { } {
  StartTag[closedBy="EndTag"] { "{%" }
  EndTag[openedBy="StartTag"] { "%}" }
  StartVariable[closedBy="EndVariable"] { "{{" }
  EndVariable[openedBy="StartVariable"] { "}}" }
}


@tokens {
  // spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
  spaces { std.whitespace+ }
  newline[@export] { $[\r\n\u2028\u2029] }
  word { identifierChar (identifierChar | std.digit )* }
  identifierChar { std.asciiLetter | $[_\u{a1}-\u{10ffff}] }
  identifier { word }



  @precedence { spaces, newline, identifier }
  @precedence { spaces, newline, word }

  RangeDevider { ":" }
  Range { "[" ("" | (std.whitespace* Number))? RangeDevider ("" | (std.whitespace* Number))? "]" }
  ObjectArgument { "[" ("'" | '"') identifier ("'" | '"') "]" }
  @precedence { Range, ObjectArgument, spaces }

  // FIXME split into multiple tokens
  сomment { "{#" blockCommentRest }
  blockCommentRest { ![#] blockCommentRest | "#" blockCommentAfterStar }
  blockCommentAfterStar { "}" | "#" blockCommentAfterStar | ![#}] blockCommentRest }



  // Number {
  //   (std.digit ("_" | std.digit)* ("." ("_" | std.digit)*)? | "." std.digit ("_" | std.digit)*)
  //     (("e" | "E") ("+" | "-")? ("_" | std.digit)+)? |
  //   std.digit ("_" | std.digit)* "n" |
  //   "0x" (std.digit | $[a-fA-F] | "_")+ "n"? |
  //   "0b" $[01_]+ "n"? |
  //   "0o" $[0-7_]+ "n"?
  // }



  Number { '-'? int frac? exp?  }
  int  { '0' | $[1-9] std.digit* }
  frac { '.' std.digit+ }
  exp  { $[eE] $[+\-]? std.digit+ }

  string {
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"?
  }

  @precedence { Number, '.' }

  // "{{" "}}" "{%" "%}"
  // "(" ")" "[" "]" "{" "}"
  // "." "," ":"

}

@detectDelim
